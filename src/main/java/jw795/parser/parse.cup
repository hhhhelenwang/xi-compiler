import java_cup.runtime.*;

//TODO: connect to lexer

/* Terminals */
terminal    Token   USE, IF, WHILE, ELSE, RETURN, LENGTH, NOT, MULT, HIGHMULT, DIV, MOD, ADD,
                        SUB, LT, LEQ, GEQ, GT, EQ, NEQ, AND, OR, COLON, ASSIGN, LPAREN, RBRACK, LBRACE,
                        RBRACE, COMMA, SEMICOLON, UNDERSCORE;

terminal    Token   INT, BOOL, INTTYPE, BOOLTYPE, ID, CHARLIT, STRINGLIT;

terminal    Token   PROGRAM_FILE, INTERFACE_FILE;

/* Non terminals */
non terminal file;
non terminal ArrayList<Use> useLst;
non terminal ArrayList<FunctionDefine> funcDefineLst;
non terminal ArrayList<FunctionDeclare> funcDeclareLst;
non terminal expr;
non terminal BlockStmt blockStmt;
non terminal Interface interface;
nonterminal Program program;


/* Precedences */
precedence nonassoc IF;
precedence nonassoc ELSE;

precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LEQ, GEQ, GT;
precedence left ADD, SUB;
precedence left MULT, HIGHMULT, DIV, MOD;

/* The grammar rules */
//This indicates which non-terminal is the start or goal non-terminal for parsing
start with file;

file ::= INTERFACE_FILE interface:i
        {: RESULT = i; :}
        | PROGRAM_FILE program:p
        {: RESULT = p; :} ;

//An interface contains a nonempty set of procedure and function declaration
//without implementation and may contain end-of-line comments
interface ::= funcDeclareLst func:f
    {:RESULT = new Interface(f);:};

//A program contains use* followed by function*
program ::= useLst use:u funcDefineLst func:f
    {: RESULT = new Program(f);:};


// ------------use------------
// multiple use declaractions must precede all procedure and function definitions
// use statements are optionally terminated by semicolon
//TODO: how to handle multiple uses
useLst ::= USE ID:interfaceName
    {:RESULT= new USE(interfaceName);:};

// ------------function------------
//A function definition starts with the name of the function, followed by its argument(s), its return type(s),
  //and the definition of its code.


// ------------expressions------------
expr ::=
    |NOT expre:e
    {: RESULT = null;:}
    | expre:e1 MULT expre:e2
    {: RESULT = null;:}
    |expre:e1 HIGHMULT expre:e2
    {: RESULT = null;:}
    | expre:e1 DIV expre:e2
    {: RESULT = null;:}
    |expre:e1 MOD expre:e2
    {: RESULT = null;:}
    |expre:e1 ADD expre:e2
    {: RESULT = null;:}
    | expre:e1 SUB expre:e2
    {: RESULT = null;:}
    |expre:e1 LT expre:e2
    {: RESULT = null;:}
    | expre:e1 LEQ expre:e2
    {: RESULT = null;:}
    |expre:e1 GEQ expre:e2
    {: RESULT = null;:}
    | expre:e1 GT expre:e2
    {: RESULT = null;:}
    | expre:e1 EQ expre:e2
    {: RESULT = null;:}
    |expre:e1 NEQ expre:e2
    {: RESULT = null;:}
    | expre:e1 AND expre:e2
    {: RESULT = null;:}
    | expre:e1 OR expre:e2
    {: RESULT = null;:};


// ------------statements------------
//A variable declaration

//OR An assignment to a variable or to an array element


//OR A return statment

//OR A call to procedure

//OR A block may be empty or may contain a sequence of statements.
block ::= statement:s
    {: RESULT = null;:};

use_statuement ::= USE:u ID:i
    {: RESULT = null; :};

//OR if and while statements
while_statement ::= WHILE:w expr:e blockStmt:b
    {: RESULT = null;:};

if_statement ::= IF expre:e blockStmt:b
    {: RESULT = null;:}
    | IF expr:e blockStmt:b ELSE blockStmt:b
    {: RESULT = null;:};

//variable declaration
var_declaration ::= ID:i COLON type:t
    {: RESULT = null;:};

