//package jw795.parser;

import java_cup.runtime.*;
import jw795.ast.*;
import java.util.ArrayList;
import java.util.Optional;
import jw795.lexer.Lexer;
import jw795.lexer.LexerAdapter;

//parser code
//    {:
//        public void syntax_error(java_cup.runtime.Symbol cur) {
//            throw new RuntimeException(String.format( "%d:%d error: unexpected `%s`", cur.left, cur.right,
//                  lexer.LexerAdapter.tokenTypeToString(Lexer.TokenType.values()[cur.sym])));
//        }
//    :}
//    ;

/* Terminals */
terminal    Symbol   USE, IF, WHILE, ELSE, RETURN, LENGTH, NOT, MULT, HIGHMULT, DIV, MOD, ADD, SUB, LT, LEQ, GEQ, GT,
                     EQ, NEQ, AND, OR, COLON, ASSIGN, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, SEMICOLON,
                     UNDERSCORE;

terminal    Symbol   INT, BOOL, INTTYPE, BOOLTYPE, ID, CHARLIT, STRINGLIT;
terminal    Symbol   PROGRAM_FILE, INTERFACE_FILE;
terminal    Symbol   UNARY;

/* Non terminals */
non terminal file;

non terminal Interface interface;
non terminal ArrayList<ProcFuncDecl> procFuncDeclLst;
non terminal ProcFuncDecl procFuncDecl;
non terminal FunctionDecl funcDecl;
non terminal ArrayList<Type> argRetTypeLst;

non terminal Program program;
//non terminal ArrayList<FunctionDefine> funcDefLst;
non terminal ArrayList<Definition> definitionLst;
non terminal ArrayList<Definition> optGlobalLst;
non terminal ArrayList<Definition> globalLst;
non terminal ArrayList<Definition> optDefinitionLst;
non terminal Definition global;
non terminal Definition procFuncDef;
non terminal ProcedureDefine procDef;
non terminal FunctionDefine funcDef;
non terminal ArrayList<Use> useLst;

non terminal function;
non terminal procedure;

non terminal ArrayList<FunProcArgs> optArgLst;
non terminal ArrayList<FunProcArgs> argLst;
non terminal funProcArgs argument;
non terminal Type argRetType;





non terminal Type arrNone;
non terminal Type arrSome;
non terminal Type arrAll;
non terminal Type primitiveType;
non terminal Type type;

non terminal BlockStmt blockStmt;
non terminal ArrayList<Statement> stmtLst;
non terminal Statement stmt;
non terminal AssignStmt assign;
non terminal AssignStmt multAssign;
non terminal ReturnStmt returnStmt;
non terminal IfStmt ifStmt;
non terminal WhileStmt whileStmt;
non terminal ProcCallStmt procCall;
non terminal VarDeclareStmt varDecl;
non terminal ArrayList<varDecl> varDeclLst;

non terminal LValue lftValue;
non terminal ArrrayList<LValue> optlftValueLst;
non terminal ArrIndexExpr arrIndexExpr;
non terminal FunCallExpr funCall;

non terminal Expr expr;
non terminal ArrayList<Expr> exprLst;
//non terminal ASTNode indexable;

non terminal optSemi;

/* Precedences */
precedence nonassoc IF;
precedence nonassoc ELSE;
precedence nonassoc ASSIGN;

precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LEQ, GEQ, GT;
precedence left ADD, SUB;
precedence left MULT, HIGHMULT, DIV, MOD;
precedence right UNARY;
precedence left LBRACK;

/* The grammar rules */
//This indicates which non-terminal is the start or goal non-terminal for parsing
start with file;

file ::= INTERFACE_FILE interface:i
        {: RESULT = i; :}
        | PROGRAM_FILE program:p
        {: RESULT = p; :}
        ;

//An interface contains a nonempty set of procedure and function declaration without implementation
interface ::= procFuncDeclLst:f
    {: int line = f.get(0).line;
       int col = f.get(0).col;
       RESULT = new Interface(f, line, col); :}
    ;

procFuncDeclLst ::= procFuncDecl:f optSemi procFuncDeclLst:d
    {: RESULT = d.add(0, f); :}
    | procFuncDecl:f
    {: ArrayList<ProcFuncDecl> lst = new ArrayList<ProcFuncDecl>(); lst.add(f); Result = lst; :}
    ;

procFuncDecl ::= ID:i LPAREN optArgLst:a RPAREN
    {: RESULT = new ProcedureDeclare(i.value, a, i.left, i.right); :}
    | ID:i LPAREN optArgLst:a RPAREN COLON argRetTypeLst:t
    {: RESULT = new FunctionDeclare(i.value, a, t, i.left, i.right); :}
    ;

optArgLst ::= argLst:a
    {: RESULT = a; :}
    | // no argument
    {: RESULT = new ArrayList<FunProcArgs>(); :}
    ;

argLst ::= argument:a COMMA argLst:l
    {: RESULT = l.add(0, a); :}
    | argument:a
    {: ArrayList<FunProcArgs> lst = new ArrayList<FunProcArgs>(); lst.add(a); RESULT = lst; :}
    ;

argument ::= ID:i COLON argRetType:t
    {: RESULT = new FunProcArgs (i.value, t, i.left, i.right); :}
    ;

argRetType ::= INTTYPE:t
    {: RESULT = new IntType(t.left, t.right); :}
    | BOOLTYPE: t
    {: RESULT = new BoolType(t.left, t.right); :}
    | argRetType:t LBRACK RBRACK
    {: RESULT = new ArrayType(t, t.left, t.right); :}
    ;

argRetTypeLst ::= argRetType:a COMMA argRetTypeLst:l
    {: l.add(0, a); RESULT = a; :}
    | argRetType:a
    {: ArrayList<Type> lst = new ArrayList<Type>(); lst.add(a); RESULT = lst; :}
    ;

optSemi ::= SEMICOLON
    | // no semicolon
    ;

//A program contains (use*) (global variable) (function*)
// int and bool can be declared and initialized + arr cannot be initialized but can be declared

//program ::= ((use∗) (definition∗))
program ::= useLst:u definitionLst:d
    {:
        int l;
        int c;
        if (u.isEmpty()) {
            l = d.get(0).line;
            c = d.get(0).column;
        } else {
            l = u.get(0).line;
            c = u.get(0).column;
        }
        RESULT = new Program(u, d, l, c);
    :}
    ;

useLst ::= useLst:ul USE:u ID:i optSemi
    {: ul.add(new Use(i, u.left, u.right)); RESULT = ul; :}
    | // empty or end of useLst
    {: RESULT = new ArrayList<Use>(); :}
    ;

//definition ::= method | globdecl
definitionLst ::= optGlobalLst:gl optDefinitionLst:dl
    {: gl.addAll(dl); RESULT = gl; :}
    ;

optGlobalLst ::= global:g optGlobalLst:l
    {: l.add(0, g); RESULT = l; :}
    | procFuncDef:f
    {: ArrayList<Definition> lst = new ArrayList<Definition>(); lst.add(f); RESULT = lst; :}
    ;

global ::= ID:i COLON argRetType:t optSemi
    {: RESULT = new GlobaDeclare(i.value, t, i.left, i.right); :}
    | ID:i COLON INTTYPE:t ASSIGN INT:n optSemi
    {:
        RESULT = new AssignStmt (
            new GlobaDeclare(i.value, new IntType(t.left, t.right), i.left, i.right),
            new IntLiteral(n.value, n.left, n.right),
            i.left,
            i.right
        );
    :}
    | ID:i COLON BOOLTYPE:t ASSIGN BOOL:b optSemi
    {:
        RESULT = new AssignStmt (
            new GlobaDeclare(i.value, new BoolType(t.left, t.right), i.left, i.right),
            new BoolLiteral(b.value, b.left, b.right),
            i.left,
            i.right
        );
    :}
    ;

optDefinitionLst ::= global:g optDefinitionLst:lst
    {: lst.add(0, g); RESULT = lst; :}
    | procFuncDef:f optDefinitionLst:lst
    {: lst.add(0, f); RESULT = lst; :}
    | //no more definition in the program
    {: RESULT = new ArrayList<Definition>(); :}
    ;

procFuncDef ::= procDef:d
    {: RESULT = d; :}
    | funcDef:d
    {: RESULT = d; :}
    ;

procDef ::= ID:i LPAREN optArgLst:a RPAREN blockStmt:b
    {: RESULT = new ProcedureDefine(i.value, a, b, i.left, i.right); :}
    ;

funcDef ::= ID:i LPAREN optArgLst:a RPAREN COLON argRetTypeLst:t blockStmt:b
    {: RESULT = new FunctionDefine(i.value, t, a, b, i.left, i.right); :}
    ;

blockStmt ::= LBRACE:l stmtLst:s RBRACE
    {: RESULT = new BlockStmt(s, l.left, l.right); :}
    | LBRACE:l stmtLst:s returnStmt:r RBRACE
    {: s.add(r); RESULT = new BlockStmt(s, l.left, l.right); :}
    ;

stmtLst ::= stmt:s optSemi stmtLst:l
    {: l.add(0, s); :}
    | // empty block or end of block
    {: RESULT = new ArrayList<Statement>(); :}
    ;

stmt ::= assign:s
    {: RESULT = s; :}
    | multAssign:s
    {: RESULT = s; :}
    | ifStmt:s
    {: RESULT = s; :}
    | whileStmt:s
    {: RESULT = s; :}
    | procCall:s
    {: RESULT = s; :}
    | blockStmt:s
    {: RESULT = s;:}
    | varDecl:s
    {: RESULT = s; :}
    ;

assign ::= lftValue:v ASSIGN expr:e
    {: RESULT = new AssignStmt(v, e, v.line, v.col); :}
    ;

lftValue ::= ID:i
    {: RESULT = new VarExpr(i.value, i.left, i.right); :}
    | varDecl:v
    {: RESULT = v; :}
    | arrIndexExpr:a
    {: RESULT = a; :}
    ;

varDecl ::= ID:i COLON type:t
    {: RESULT = new VarDeclareStmt(i, t, i.left, i.right);:}
    | UNDERSCORE:u
    {: RESULT = new WildCard(u.left, u.right); :}
    ;

type ::= arrNone:a
    {: RESULT = new ArrayType(a, Optional.empty(), a.line, a.col); :}
    | arrSome:a
    {: RESULT = new ArrayType(a, Optional.empty(), a.line, a.col); :}
    | arrAll:a
    {: RESULT = a; :}
    ;

arrNone ::= arrNone:a LBRACK RBRACK
    {: RESULT = new ArrayType(a, Optional.empty(), a.line, a.col); :}
    | primitiveType:p LBRACK RBRACK
    {: RESULT = p; :}
    ;

primitiveType ::= INTTYPE:i
    {: RESULT = new IntType(i.left, i.col); :}
    | BOOLTYPE:b
    {: RESULT = new BoolType(i.left, i.col); :}
    ;

arrSome ::= arrSome:a LBRACK RBRACK
    {: RESULT = new ArrayType(a, Optional.empty(), a.line, a.col); :}
    | arrAll:a LBRACK RBRACK
    {: RESULT = a; :}
    ;

arrAll ::= arrAll:a LBRACK expr:e RBRACK
    {: RESULT = new ArrayType(a, Optional.of(e), a.line, a.col); :}
    | primitiveType:p
    {: RESULT = p; :}
    ;

expr ::= INT: i
    {: RESULT = new IntLiteral(i.value, i.left, i.right); :}
    | BOOL: b
    {: RESULT = new BoolLiteral(b.value, b.left, b.right); :}
    | CHARLIT: c
    {: RESULT = new CharLiteral(c.value, c.left, c.right); :}
    | STRINGLIT: s
    {: RESULT = new StringLit(s.value, s.left, s.right); :}
    | STRINGLIT:s LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(new StringLit (s.value, s.left, s.right), e, s.left, s.right); :}
    | LPAREN expr:e RPAREN
    {: RESULT = e; :}
    | NOT:not expr:e
    {: RESULT = new Not(e, not.left, not.right);:} %prec UNARY
    | expr:e1 MULT expr:e2
    {: RESULT = new Mult(e1, e2, e1.left, e1.right);:}
    | expr:e1 HIGHMULT expr:e2
    {: RESULT = new HighMult(e1, e2, e1.left, e1.right);:}
    | expr:e1 DIV expr:e2
    {: RESULT = new Div(e1, e2, e1.left, e1.right);:}
    | expr:e1 MOD expr:e2
    {: RESULT = new Mod(e1, e2, e1.left, e1.right);:}
    | expr:e1 ADD expr:e2
    {: RESULT = new Add(e1, e2, e1.left, e1.right);:}
    | expr:e1 SUB expr:e2
    {: RESULT = new Sub(e1, e2, e1.left, e1.right);:}
    | SUB:sub expr:e
    {: RESULT = new IntNeg(e, sub.left, sub.right);:} %prec UNARY
    | expr:e1 LT expr:e2
    {: RESULT = new LessThan(e1, e2, e1.left, e1.right);:}
    | expr:e1 LEQ expr:e2
    {: RESULT = new LessEq(e1, e2, e1.left, e1.right);:}
    | expr:e1 GEQ expr:e2
    {: RESULT = new GreaterEq(e1, e2, e1.left, e1.right);:}
    | expr:e1 GT expr:e2
    {: RESULT = new GreaterThan(e1, e2, e1.left, e1.right);:}
    | expr:e1 EQ expr:e2
    {: RESULT = new Equal(e1, e2, e1.left, e1.right);:}
    | expr:e1 NEQ expr:e2
    {: RESULT = new NotEqual(e1, e2, e1.left, e1.right);:}
    | expr:e1 AND expr:e2
    {: RESULT = new And(e1, e2, e1.left, e1.right);:}
    | expr:e1 OR expr:e2
    {: RESULT = new Or(e1, e2, e1.left, e1.right);:}
    ;

arrIndexExpr ::= ID:i LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(i.value, e, i.left, i.right); :}
    | funCall:f LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(f, e, f.left, f.right); :}
    | arrIndexExpr:a LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(a, e, a.line, a.col); :}
    ;

funCall ::= ID:i LPAREN exprLst:e RPAREN
    {: RESULT = new FunCallExpr(i.value, e, i.left, i.right); :}
    | ID:i LPAREN RPAREN
    {: RESULT = new FunCallExpr(i.value, new ArrayList<Expr>(), i.left, i.right); :}
    | LENGTH:len LPAREN expr:e RPAREN
    {: ArrayList<Expr> lst = new ArrayList<Expr>();
       lst.add(e);
       RESULT = new FunCallExpr("length", lst, len.left, len.right); :}
    ;

// function can take in 0 or more arguments (/expression)
exprLst ::= expr:e COMMA exprLst:l
    {: RESULT = l.add(0, e); :}
    | expr:e
    {: ArrayList<Type> lst = new ArrayList<Type>(); lst.add(e); RESULT = lst; :}
    ;

multAssign ::= varDeclLst:l ASSIGN funCall:f
    {: int line = l.get(0).line;
       int col = l.get(0).col;
       RESULT = new AssignStmt(new LeftValueList(l, line, col), f, line, col); :}
    ;

//variable declaration
varDeclLst ::= varDecl:v COMMA varDeclLst:l
    {: l.add(0, v); RESULT = l; :}
    | varDecl:v1 COMMA varDecl:v2
    {: ArrayList<LValue> lst = new ArrayList<LValue>(); lst.addAll(v1); lst.addAll(v2); RESULT = lst; :}
    ;

ifStmt ::= IF:i expr:e stmt:s
    {: RESULT = new ifStmt(e, s, i.left, i.right);:}
    | IF:i expr:e stmt:s1 ELSE stmt:s2
    {: RESULT = new ifStmt(e, s1, s2, i.left, i.right); :}
    ; /// ifStmt constructer

//OR if and while statements
whileStmt ::= WHILE:w expr:e stmt:s
    {: RESULT = new WhileStmt(e, s, w.left, w.right); :}
    ;

procCall ::= ID:i LPAREN exprLst:a RPAREN
    {: RESULT = new ProcCallStmt(i.value, a, i.left, i.right); :}
    | ID:i LPAREN RPAREN
    {: RESULT = new ProcCallStmt(i.value, new ArrayList<Expr>(), i.left, i.right); :}
    ;

returnStmt ::= RETURN:r exprLst:l optSemi
    {: RESULT = new ReturnStmt(l, r.left, r.right); :}
    ;

