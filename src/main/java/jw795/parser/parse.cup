import java_cup.runtime.*;
//TODO: connect to lexer

/* Terminals */
terminal    Symbol   USE, IF, WHILE, ELSE, RETURN, LENGTH, NOT, MULT, HIGHMULT, DIV, MOD, ADD, SUB, LT, LEQ, GEQ, GT,
                     EQ, NEQ, AND, OR, COLON, ASSIGN, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, SEMICOLON,
                     UNDERSCORE;

terminal    Symbol   INT, BOOL, INTTYPE, BOOLTYPE, ID, CHARLIT, STRINGLIT;
terminal    Symbol   PROGRAM_FILE, INTERFACE_FILE;
terminal    Symbol   UNARY;

/* Non terminals */
non terminal file;

non terminal Interface interface;
non terminal ArrayList<FunctionDeclare> funcDeclLst;
non terminal FunctionDecl funcDecl;

non terminal Program program;
non terminal ArrayList<FunctionDefine> funcDefLst;
non terminal FunctionDefine funcDef;
non terminal ArrayList<Use> useLst;

non terminal function;
non terminal procedure;
non terminal functionInterface;
non terminal procedureInterface;

non terminal ArrayList<FunProcArgs> optArgLst;
non terminal ArrayList<FunProcArgs> argLst;
non terminal ArrayList<Type> optTypeLst;
non terminal ArrayList<Type> typeLst;
non terminal Type type;

non terminal BlockStmt blockStmt;
non terminal BlockStmt retBlockStmt;
non terminal BlockStmt noRetBlockStmt;
non terminal ArrayList<Statement> optStmtLst;
non terminal ArrayList<Statement> stmtLst;
non terminal Statement stmt;
non terminal ReturnStmt returnStmt;

non terminal LValue lftValue;

non terminal Expr expr;

/* Precedences */
precedence nonassoc IF;
precedence nonassoc ELSE;

precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LEQ, GEQ, GT;
precedence left ADD, SUB;
precedence left MULT, HIGHMULT, DIV, MOD;
precedence right UNARY;

/* The grammar rules */
//This indicates which non-terminal is the start or goal non-terminal for parsing
start with file;

file ::= INTERFACE_FILE interface:i
        {: RESULT = i; :}
        | PROGRAM_FILE program:p
        {: RESULT = p; :}
        ;

//A program contains (use*) (function*)
program ::= useLst:u funcDefLst:f
    {: RESULT = new Program(u, f); :}
    ;

useLst ::= useLst:ul USE ID:interfaceName
    {:
        ul.add(new Use(interfaceName));
        RESULT = ul;
    :}
    |
    {: ArrayList<Use> useList = new ArrayList<Use>(); RESULT = useList; :}
    ;

funcDefLst ::= funcDef:f funcDefLst:dl
    {: dl.add(f); RESULT = dl; :}
    | funcDef:f
    {: ArrayList<FunctionDefine> lst = new ArrayList<>(FunctionDefine); lst.add(f); RESULT = lst;:}
    ;

funcDef ::= function:f
    {: RESULT = f; :}
    | procedure:p
    {: RESULT = p; :}
    ;

function ::= ID:i LPAREN optArgLst:a RPAREN COLON optTypeLst:t LBRACE retBlockStmt:b RBRACE
    {: RESULT = new FunctionDefine(i.value, t, a, b); :}
    ;

procedure ::= ID LPAREN optArgLst:a RPAREN LBRACE noRetBlockStmt:b RBRACE
    {: RESULT = new FunctionDefine(i.value, t, a, b); :}
    ;
//An interface contains a nonempty set of procedure and function declaration without implementation
interface ::= funcDeclLst:f
    {:RESULT = new Interface(f); :}
    ;

funcDeclLst ::= funcDecl:f funcDeclLst:d
    {: RESULT = d.add(0, f); :}
    | funcDecl:f
    {: ArrayList<FunctionDeclare> list = new ArrayList<FunctionDeclare>(); list.add(f); Result = list; :} ;

funcDecl ::= functionInterface:f
    {: RESULT = f; :}
    | procedureInterface:p
    {: RESULT = p; :}
    ;

functionInterface ::= ID:i LPAREN optArgLst:a RPAREN COLON optTypeLst:t LBRACE RBRACE
    {: RESULT = new FunctionDeclare(i.value, a, t); :}
    ;

procedureInterface ::= ID LPAREN optArgLst:a RPAREN LBRACE RBRACE
    {: RESULT = new FunctionDeclare(i.value, a, t); :}
    ;

optArgLst ::= argLst:a
    {: RESULT = a; :}
    |
    {: RESULT = Optional.empty(); :}
    ;

argLst ::= argument:a COMMA argLst:l
    {: RESULT = l.add(0, a); :}
    | argument:a
    {: ArrayList<FunProcArgs> list = new ArrayList<FunProcArgs>(); list.add(a); RESULT = Optional.of(list); :}
    ;

argument ::= ID:i COLON type:t
    {: RESULT = new FunProcArgs (i.value, t); :}
    ;

optTypeLst ::= typeLst:t
    {: RESULT = t; :}
    |
    {: RESULT = Optional.empty(); :}
    ;

typeLst ::= type:t COMMA typeLst:l
    {: RESULT = l.add(0, t); :}
    | type:t
    {: ArrayList<Type> list = new ArrayList<Type>(); list.add(t); RESULT = Optional.of(list); :}
    ;

type ::= INTTYPE
    {: RESULT = new IntType(); :}
    | BOOLTYPE
    {: RESULT = new BoolType(); :}
    | type:t LBRACK RBRACK
    {: RESULT = new ArrayType(t); :}
    ;

retBlockStmt ::= optStmtLst:o returnStmt:r
    {: RESULT = new BlockStmt(o.add(r)); :}
    ;

noRetBlockStmt ::= optStmtLst:o
    {: RESULT = new BlockStmt(o); :}
    ;

optStmtLst ::= stmtLst:s
    {: RESULT = s; :}
    |
    {: RESULT = new ArrayList<Statement>(); :}
    ;

stmtLst ::= stmt:s stmtLst:l
    {: l.add(0, s); :}
    | stmt:s
    {: ArrayList<Statement> list = new ArrayList<Statement>(); list.add(s); RESULT = list; :}
    ;

stmt ::= assign:s
    {: RESULT = s; :}
    | ifStmt:s
    {: RESULT = s; :}
    | whileStmt:s
    {: RESULT = s; :}
    | procCall:s
    {: RESULT = s; :}
    | varDecl:s
    {: RESULT = s; :}
    | blockStmt:s
    {: RESULT = s;:}
    ;

assign ::= lftValue:v ASSIGN expr:e
    {: RESULT = new AssignStmt(v, e); :}
    ;

lftValue ::= varDecl:v
    {: RESULT = v; :}
    | UNDERSCORE
    {: RESULT = null;:}
    ;

ifStmt ::= IF expre:e stmt:s
    {: RESULT = new ifStmt(e, s);:}
    | IF expr:e stmt:s1 ELSE stmt:s2
    {: RESULT = new ifStmt(e, s1, s2);:}
    ; /// ifStmt constructer

//OR if and while statements
whileStmt ::= WHILE expr:e stmt:s
    {: RESULT = new WhileStmt(e, s);:}
    ;

procCall ::= ID:i LPAREN optArgLst:a RPAREN
    {: RESULT = new ProcCallStmt(i, a); :}
    ;

//variable declaration TODO: multiple declaraton
varDecl::= ID:i COLON type:t
    {: RESULT = null;:};

/* block ::= (statement*) */
blockStmt ::= retBlockStmt:r
    {: RESULT = r; :}
    |noRetBlockStmt:n
    {: RESULT = n; :}
    ;


// ------------expressions------------
expr ::=
    |NOT expre:e
    {: RESULT = new Not(e);:} %prec UNARY
    | expre:e1 MULT expre:e2
    {: RESULT = new Mult(e1, e2);:}
    |expre:e1 HIGHMULT expre:e2
    {: RESULT = new HighMult(e1, e2);:}
    | expre:e1 DIV expre:e2
    {: RESULT = new Div(e1, e2);:}
    |expre:e1 MOD expre:e2
    {: RESULT = new Mod(e1, e2);:}
    |expre:e1 ADD expre:e2
    {: RESULT = new Add(e1, e2);:}
    | expre:e1 SUB expre:e2
    {: RESULT = new Sub(e1, e2);:}
    | sub expre:e
    {: RESULT = new IntNeg(e);:} %prec UNARY
    |expre:e1 LT expre:e2
    {: RESULT = new LessThan(e1, e2);:}
    | expre:e1 LEQ expre:e2
    {: RESULT = new LessEq(e1, e2);:}
    |expre:e1 GEQ expre:e2
    {: RESULT = new GreaterEq(e1, e2);:}
    | expre:e1 GT expre:e2
    {: RESULT = new GreaterThan(e1, e2);:}
    | expre:e1 EQ expre:e2
    {: RESULT = new Equal(e1, e2);:}
    |expre:e1 NEQ expre:e2
    {: RESULT = new NotEqual(e1, e2);:}
    | expre:e1 AND expre:e2
    {: RESULT = new And(e1, e2);:}
    | expre:e1 OR expre:e2
    {: RESULT = new Or(e1, e2);:};


// ------------statements------------
//A variable declaration

//OR An assignment to a variable or to an array element


//OR A return statment

//OR A call to procedure

//OR A block may be empty or may contain a sequence of statements.








