package jw795.parser;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Optional;
import jw795.ast.*;
import jw795.lexer.Lexer;
import jw795.lexer.LexerAdapter;
import java.math.BigInteger;


/**
 * syntax_error(java_cup.runtime.Symbol cur) overrides the default function in the generated parser class
 * to throw an RuntimeException with an error message reporting the Symbol location and type.
 */
parser code
    {:
        public void syntax_error(java_cup.runtime.Symbol cur) {
            throw new RuntimeException(String.format( "%d:%d error:Unexpected token `%s`", cur.left + 1, cur.right + 1,
                  LexerAdapter.tokenTypeToString(cur.sym)));
        }
    :}
    ;

/* Terminals */
terminal        USE, IF, WHILE, ELSE, RETURN, LENGTH, NOT, MULT, HIGHMULT, DIV, MOD, ADD, SUB, LT, LEQ, GEQ, GT,
                     EQ, NEQ, AND, OR, COLON, ASSIGN, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, SEMICOLON,
                     UNDERSCORE;
terminal        PROGRAM_FILE, INTERFACE_FILE;
terminal        INTTYPE, BOOLTYPE;
terminal        UNARY;

terminal    BigInteger    INT;
terminal    Boolean BOOL;
terminal    String  ID;
terminal    Character    CHARLIT;
terminal    String  STRINGLIT;

/* Non terminals */
non terminal file;

// interface
non terminal Interface interface;
// might need to change because procFuncDeclLst
non terminal ArrayList<ProcFuncDecl> procFuncDeclLst;
non terminal ProcFuncDecl procFuncDecl;

// program
non terminal Program program;
non terminal ArrayList<Definition> definitionLst;
non terminal ArrayList<Definition> optGlobalLst;
non terminal ArrayList<Definition> optDefinitionLst;
non terminal Definition global;
non terminal Definition procFuncDef;
non terminal ProcedureDefine procDef;
non terminal FunctionDefine funcDef;
non terminal ArrayList<Use> useLst;
non terminal ArrayList<FunProcArgs> optArgLst;
non terminal ArrayList<FunProcArgs> argLst;
non terminal FunProcArgs argument;
non terminal Type argRetType;

// type
non terminal Type type;
non terminal Type primitiveType;
non terminal Type arrNone;
non terminal Type arrSome;
non terminal Type arrAll;
non terminal ArrayList<Type> argRetTypeLst;

// statement
non terminal BlockStmt blockStmt;
non terminal ArrayList<Statement> stmtLst;
non terminal Statement stmt;
non terminal AssignStmt assign;
non terminal AssignStmt multAssign;
non terminal ReturnStmt returnStmt;
non terminal Statement ifStmt;
non terminal WhileStmt whileStmt;
non terminal ProcCallStmt procCall;
//non terminal VarDeclareStmt varDecl;
//non terminal ArrayList<VarDeclareStmt> varDeclLst;
// because wildcard and VarDeclareStmt are different types
non terminal WildCard wildcard;
//non terminal LValue varDecl;
non terminal VarDeclareStmt varDecl;
non terminal LValue lftValueMulti;
non terminal ArrayList<LValue> lftValueMultiLst;

// expressions
non terminal Expr expr;
non terminal ArrayList<Expr> exprLst;
non terminal LValue lftValue;
non terminal ArrIndexExpr arrIndexExpr;
non terminal FunCallExpr funCall;

// punctuation
non terminal optSemi;

/* Precedences */
precedence nonassoc IF;
precedence nonassoc ELSE;
precedence nonassoc ASSIGN;

precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LEQ, GEQ, GT;
precedence left ADD, SUB;
precedence left MULT, HIGHMULT, DIV, MOD;
precedence right UNARY;
precedence left LBRACK;

/* The grammar rules */

/**
* ===== FILE PROCESSING ====
* A file can be either a program file or an interface file. A Symbol is used to indicate which file it is.
*/
start with file;

file ::= INTERFACE_FILE interface:i
        {: RESULT = i; :}
        | PROGRAM_FILE program:p
        {: RESULT = p; :}
        ;

/**
* ===== INTERFACE PROCESSING ====
* The general syntax of an interface is defined as interface ::= ((procFuncDec∗))
*/
interface ::= procFuncDeclLst:f
    {: int line = f.get(0).getLine();
       int col = f.get(0).getCol();
       RESULT = new Interface(f, line, col); :}
    ;

procFuncDeclLst ::= procFuncDecl:f optSemi procFuncDeclLst:d
    {: d.add(0, f); RESULT = d; :}
    | procFuncDecl:f
    {: ArrayList<ProcFuncDecl> lst = new ArrayList<ProcFuncDecl>(); lst.add(f); RESULT = lst; :}
    ;

procFuncDecl ::= ID:i LPAREN optArgLst:a RPAREN
    {: RESULT = new ProcedureDeclare(i, a, ileft, iright); :}
    | ID:i LPAREN optArgLst:a RPAREN COLON argRetTypeLst:t
    {: RESULT = new FunctionDeclare(i, a, t, ileft, iright); :}
    ;

optArgLst ::= argLst:a
    {: RESULT = a; :}
    | // no argument was passed in
    {: RESULT = new ArrayList<FunProcArgs>(); :}
    ;

argLst ::= argument:a COMMA argLst:l
    {: l.add(0, a); RESULT = l; :}
    | argument:a
    {: ArrayList<FunProcArgs> lst = new ArrayList<FunProcArgs>(); lst.add(a); RESULT = lst; :}
    ;

argument ::= ID:i COLON argRetType:t
    {: RESULT = new FunProcArgs (i, t, ileft, iright); :}
    ;

argRetType ::= INTTYPE:t
    {: RESULT = new IntType(tleft, tright); :}
    | BOOLTYPE: t
    {: RESULT = new BoolType(tleft, tright); :}
    | argRetType:t LBRACK RBRACK
    {: RESULT = new ArrayType(t, t.getLine(), t.getCol()); :}
    ;

argRetTypeLst ::= argRetType:a COMMA argRetTypeLst:l
    {: l.add(0, a); RESULT = l; :}
    | argRetType:a
    {: ArrayList<Type> lst = new ArrayList<Type>(); lst.add(a); RESULT = lst; :}
    ;

optSemi ::= SEMICOLON
    | // no semicolon
    ;

/**
* ===== PROGRAM PROCESSING ====
* The general syntax of an interface is defined as program ::= ((use∗) (definition∗))
*/
program ::= useLst:u definitionLst:d
    {:
        int l;
        int c;
        if (u.isEmpty()) {
            l = d.get(0).getLine();
            c = d.get(0).getCol();
        } else {
            l = u.get(0).getLine();
            c = u.get(0).getCol();
        }
        RESULT = new Program(u, d, l, c);
    :}
    ;

// use ::= (use <id>)
useLst ::= useLst:ul USE:u ID:i optSemi
    {: ul.add(new Use(i, uleft, uright)); RESULT = ul; :}
    | // empty or end of useLst
    {: RESULT = new ArrayList<Use>(); :}
    ;

// definition ::= method | globdecl
definitionLst ::= optGlobalLst:gl optDefinitionLst:dl
    {: gl.addAll(dl); RESULT = gl; :}
    ;

optGlobalLst ::= global:g optGlobalLst:l
    {: l.add(0, g); RESULT = l; :}
    | procFuncDef:f
    {: ArrayList<Definition> lst = new ArrayList<Definition>(); lst.add(f); RESULT = lst; :}
    ;

// globdec ::= (<id> type) |  (<id> type <value>)
global ::= ID:i COLON argRetType:t optSemi
    {: RESULT = new GlobDeclare(i, t, ileft, iright); :}
    | ID:i COLON INTTYPE:t ASSIGN INT:n optSemi
    {:
        RESULT = new AssignStmt (
            new GlobDeclare(i, new IntType(tleft, tright), ileft, iright),
            new IntLiteral(n, nleft, nright),
            ileft,
            iright
        );
    :}
    | ID:i COLON BOOLTYPE:t ASSIGN BOOL:b optSemi
    {:
        RESULT = new AssignStmt (
            new GlobDeclare(i, new BoolType(tleft, tright), ileft, iright),
            new BoolLiteral(b, bleft, bright),
            ileft,
            iright
        );
    :}
    ;

optDefinitionLst ::= global:g optDefinitionLst:lst
    {: lst.add(0, g); RESULT = lst; :}
    | procFuncDef:f optDefinitionLst:lst
    {: lst.add(0, f); RESULT = lst; :}
    | //no more definition in the program
    {: RESULT = new ArrayList<Definition>(); :}
    ;

procFuncDef ::= procDef:d
    {: RESULT = d; :}
    | funcDef:d
    {: RESULT = d; :}
    ;

procDef ::= ID:i LPAREN optArgLst:a RPAREN blockStmt:b
    {: RESULT = new ProcedureDefine(i, a, b, ileft, iright); :}
    ;

funcDef ::= ID:i LPAREN optArgLst:a RPAREN COLON argRetTypeLst:t blockStmt:b
    {: RESULT = new FunctionDefine(i, t, a, b, ileft, iright); :}
    ;

/**
* ===== BLOCK PROCESSING ====
* The general syntax of an interface is defined as Block ::= (stmt*)
*/
blockStmt ::= LBRACE:l stmtLst:s RBRACE
    {: RESULT = new BlockStmt(s, lleft, lright); :}
    | LBRACE:l stmtLst:s returnStmt:r RBRACE
    {: s.add(r); RESULT = new BlockStmt(s, lleft, lright); :}
    ;

returnStmt ::= RETURN:r exprLst:l optSemi
    {: RESULT = new ReturnStmt(l, rleft, rright); :}
    ;

/**
* ===== STATEMENT PROCESSING ====
* The general syntax of an interface is defined as
* stmt ::=  ifStmt | whileStmt | procCall | assign | multiAssign | blockStmt | varDecl
*/
stmtLst ::= stmt:s optSemi stmtLst:l
    {: l.add(0, s); RESULT = l; :}
    | // empty block or end of block
    {: RESULT = new ArrayList<Statement>(); :}
    ;

stmt ::= ifStmt:s
    {: RESULT = s; :}
    | whileStmt:s
    {: RESULT = s; :}
    | procCall:s
    {: RESULT = s; :}
    | assign:s
    {: RESULT = s; :}
    | multAssign:s
    {: RESULT = s; :}
    | blockStmt:s
    {: RESULT = s;:}
    | varDecl:s
    {: RESULT = s; :}
    ;

ifStmt ::= IF:i expr:e stmt:s
    {: RESULT = new IfStmt(e, s, ileft, iright);:}
    | IF:i expr:e stmt:s1 ELSE stmt:s2
    {: RESULT = new IfElseStmt(e, s1, s2, ileft, iright); :}
    ;

whileStmt ::= WHILE:w expr:e stmt:s
    {: RESULT = new WhileStmt(e, s, wleft, wright); :}
    ;

procCall ::= ID:i LPAREN exprLst:a RPAREN
    {: RESULT = new ProcCallStmt(i, a, ileft, iright); :}
    ;

// Single Assignment is defined as Assign ::= (ID | varDecl | arrIndexExpr) ASSIGN expr
assign ::= lftValue:v ASSIGN expr:e
    {: RESULT = new AssignStmt(v, e, v.getLine(), v.getCol()); :}
    ;

lftValue ::= ID:i
    {: RESULT = new VarExpr(i, ileft, iright); :}
    | varDecl:v
    {: RESULT = v; :}
    | arrIndexExpr:a
    {: RESULT = a; :}
    | UNDERSCORE:u
    {: RESULT = new WildCard(uleft, uright); :}
    ;

type ::= arrNone:a
    {: RESULT = a; :}
    | arrSome:a
    {: RESULT = a; :}
    | arrAll:a
    {: RESULT = a; :}
    | primitiveType:p
    {: RESULT = p; :}
    ;

arrNone ::= arrNone:a LBRACK RBRACK
    {: RESULT = new ArrayType(a, a.getLine(), a.getCol()); :}
    | primitiveType:p LBRACK RBRACK
    {: RESULT = new ArrayType(p, p.getLine(), p.getCol()); :}
    ;

primitiveType ::= INTTYPE:i
    {: RESULT = new IntType(ileft, iright); :}
    | BOOLTYPE:b
    {: RESULT = new BoolType(bleft, bright); :}
    ;

arrSome ::= arrSome:a LBRACK RBRACK
    {: RESULT = new ArrayType(a, a.getLine(), a.getCol()); :}
    | arrAll:a LBRACK RBRACK
    {: RESULT = new ArrayType(a, a.getLine(), a.getCol()); :}
    ;

arrAll ::= arrAll:a LBRACK expr:e RBRACK
    {: RESULT = new ArrayType(a, e, a.getLine(), a.getCol()); :}
    | primitiveType:p LBRACK expr:e RBRACK
    {: RESULT = new ArrayType(p, e, p.getLine(), p.getCol()); :}
    ;

expr ::= INT: i
    {: RESULT = new IntLiteral(i, ileft, iright); :}
    | BOOL: b
    {: RESULT = new BoolLiteral(b, bleft, bright); :}
    | CHARLIT: c
    {: RESULT = new CharLiteral(c, cleft, cright); :}
    | STRINGLIT: s
    {: RESULT = new StringLit(s, sleft, sright); :}
    | NOT:not expr:e
    {: RESULT = new Not(e, notleft, notright);:} %prec UNARY
    | expr:e1 MULT expr:e2
    {: RESULT = new Mult(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 HIGHMULT expr:e2
    {: RESULT = new HighMult(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 DIV expr:e2
    {: RESULT = new Div(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 MOD expr:e2
    {: RESULT = new Mod(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 ADD expr:e2
    {: RESULT = new Add(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 SUB expr:e2
    {: RESULT = new Sub(e1, e2, e1.getLine(), e1.getCol());:}
    | SUB:sub expr:e
    {: RESULT = new IntNeg(e, subleft, subright);:} %prec UNARY
    | expr:e1 LT expr:e2
    {: RESULT = new LessThan(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 LEQ expr:e2
    {: RESULT = new LessEq(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 GEQ expr:e2
    {: RESULT = new GreaterEq(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 GT expr:e2
    {: RESULT = new GreaterThan(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 EQ expr:e2
    {: RESULT = new Equal(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 NEQ expr:e2
    {: RESULT = new NotEqual(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 AND expr:e2
    {: RESULT = new And(e1, e2, e1.getLine(), e1.getCol());:}
    | expr:e1 OR expr:e2
    {: RESULT = new Or(e1, e2, e1.getLine(), e1.getCol());:}
    | ID:i
    {: RESULT = new VarExpr(i, ileft, iright); :}
    | funCall: f
    {: RESULT = f; :}
    | LPAREN expr:e RPAREN
    {: RESULT = e; :}
    | expr:e1 LBRACK expr:e2 RBRACK
    {: RESULT = new ArrIndexExpr(e1, e2, e1.getLine(), e1.getCol()); :}
    | LBRACE:l exprLst:e RBRACE
    {: RESULT = new ArrayExpr(e, lleft, lright); :}
    ;

arrIndexExpr ::= ID:i LBRACK expr:e RBRACK
    {:
        VarExpr expr = new VarExpr(i, ileft, iright);
        RESULT = new ArrIndexExpr(expr, e, ileft, iright);
    :}
    | funCall:f LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(f, e, f.getLine(), f.getCol()); :}
    | arrIndexExpr:a LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(a, e, a.getLine(), a.getCol()); :}
    ;

funCall ::= ID:i LPAREN exprLst:e RPAREN
    {: RESULT = new FunCallExpr(i, e, ileft, iright); :}
    | LENGTH:len LPAREN expr:e RPAREN
    {: ArrayList<Expr> lst = new ArrayList<Expr>();
       lst.add(e);
       RESULT = new FunCallExpr("length", lst, lenleft, lenright); :}
    ;

exprLst ::= expr:e COMMA exprLst:l
    {: l.add(0, e); RESULT = l; :}
    | expr:e
    {: ArrayList<Expr> lst = new ArrayList<Expr>(); lst.add(e); RESULT = lst; :}
    |
    {: ArrayList<Expr> lst = new ArrayList<Expr>(); RESULT = lst; :}
    ;

multAssign ::= lftValueMultiLst:l ASSIGN funCall:f
    {:
        int line = l.get(0).getLine();
        int col = l.get(0).getCol();
        LeftValueList lst = new LeftValueList(l, line, col);
        RESULT = new AssignStmt(lst, f, line, col);
    :}
    ;

lftValueMultiLst ::= lftValueMulti:v COMMA lftValueMultiLst:l
    {: l.add(0, v); RESULT = l; :}
    | lftValueMulti:v1 COMMA lftValueMulti:v2
    {: ArrayList<LValue> lst = new ArrayList<LValue>(); lst.add(v1); lst.add(v2); RESULT = lst; :}
    ;

lftValueMulti ::= varDecl: v
    {: RESULT = v; :}
    | wildcard: w
    {: RESULT = w; :}
    ;

varDecl ::= ID:i COLON type:t
    {: RESULT = new VarDeclareStmt(i, t, ileft, iright); :}
    ;

wildcard ::= UNDERSCORE:u
    {: RESULT = new WildCard(uleft, uright); :}
    ;