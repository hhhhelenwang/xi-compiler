import java_cup.runtime.*;
import jw795.ast.*;
import jw795.util.ArrayList;
import jw795.util.Optional;
import jw795.lexer.lexer;

//TODO: connect to lexer

/* Terminals */
terminal    Symbol   USE, IF, WHILE, ELSE, RETURN, LENGTH, NOT, MULT, HIGHMULT, DIV, MOD, ADD, SUB, LT, LEQ, GEQ, GT,
                     EQ, NEQ, AND, OR, COLON, ASSIGN, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, SEMICOLON,
                     UNDERSCORE;

terminal    Symbol   INT, BOOL, INTTYPE, BOOLTYPE, ID, CHARLIT, STRINGLIT;
terminal    Symbol   PROGRAM_FILE, INTERFACE_FILE;
terminal    Symbol   UNARY;

/* Non terminals */
non terminal file;

non terminal Interface interface;
non terminal ArrayList<FunctionDeclare> funcDeclLst;
non terminal FunctionDecl funcDecl;

non terminal Program program;
non terminal ArrayList<FunctionDefine> funcDefLst;
non terminal FunctionDefine funcDef;
non terminal ArrayList<Use> useLst;

non terminal function;
non terminal procedure;
non terminal functionInterface;
non terminal procedureInterface;

non terminal ArrayList<FunProcArgs> optArgLst;
non terminal ArrayList<FunProcArgs> argLst;
non terminal funProcArgs argument;
non terminal ArrayList<Type> optTypeLst;
non terminal ArrayList<Type> typeLst;
non terminal Type type;

non terminal BlockStmt blockStmt;
non terminal ArrayList<Statement> optStmtLst;
non terminal ArrayList<Statement> stmtLst;
non terminal Statement stmt;
non terminal AssignStmt assign;
non terminal ReturnStmt returnStmt;
non terminal IfStmt ifStmt;
non terminal WhileStmt whileStmt;
non terminal ProcCallStmt procCall;
non terminal VarDeclareStmt varDecl;

non terminal LValue lftValue;
non terminal ArrIndexExpr arrIndexExpr;
non terminal FunCallExpr funCall;

non terminal Expr expr;
non terminal ASTNode indexable;

non terminal optSemi;

/* Precedences */
precedence nonassoc IF;
precedence nonassoc ELSE;

precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LEQ, GEQ, GT;
precedence left ADD, SUB;
precedence left MULT, HIGHMULT, DIV, MOD;
precedence right UNARY;
//precedence left LBRACK;

/* The grammar rules */
//This indicates which non-terminal is the start or goal non-terminal for parsing
start with file;

optSemi ::= SEMICOLON
    | // no semicolon
    ;

file ::= INTERFACE_FILE interface:i
        {: RESULT = i; :}
        | PROGRAM_FILE program:p
        {: RESULT = p; :}
        ;

//A program contains (use*) (function*)
program ::= useLst:u funcDefLst:f
    {: RESULT = new Program(u, f); :}
    ;

useLst ::= useLst:ul USE ID:interfaceName optSemi
    {:
        ul.add(new Use(interfaceName));
        RESULT = ul;
    :}
    | // empty or end of useLst
    {: RESULT = new ArrayList<Use>(); :}
    ;

funcDefLst ::= funcDef:f funcDefLst:dl
    {: dl.add(f); RESULT = dl; :}
    | funcDef:f
    {: ArrayList<FunctionDefine> lst = new ArrayList<>(FunctionDefine); lst.add(f); RESULT = lst;:}
    ;

funcDef ::= function:f
    {: RESULT = f; :}
    | procedure:p
    {: RESULT = p; :}
    ;

function ::= ID:i LPAREN optArgLst:a RPAREN COLON optTypeLst:t blockStmt:b
    {: RESULT = new FunctionDefine(i.value, t, a, b); :}
    ;

procedure ::= ID LPAREN optArgLst:a RPAREN blockStmt:b
    {: RESULT = new FunctionDefine(i.value, Optional.empty(), a, b); :}
    ;

//An interface contains a nonempty set of procedure and function declaration without implementation
interface ::= funcDeclLst:f
    {:RESULT = new Interface(f); :}
    ;

funcDeclLst ::= funcDecl:f funcDeclLst:d
    {: RESULT = d.add(0, f); :}
    | funcDecl:f
    {: ArrayList<FunctionDeclare> lst = new ArrayList<FunctionDeclare>(); lst.add(f); Result = lst; :} ;

funcDecl ::= functionInterface:f
    {: RESULT = f; :}
    | procedureInterface:p
    {: RESULT = p; :}
    ;

functionInterface ::= ID:i LPAREN optArgLst:a RPAREN COLON typeLst:t LBRACE RBRACE
    {: RESULT = new FunctionDeclare(i.value, a, t); :}
    ;

procedureInterface ::= ID:i LPAREN optArgLst:a RPAREN
    {: RESULT = new FunctionDeclare(i.value, a, Optional.empty()); :}
    ;

optArgLst ::= argLst:a
    {: RESULT = a; :}
    | // no argument
    {: RESULT = Optional.empty(); :}
    ;

argLst ::= argument:a COMMA argLst:l
    {: RESULT = l.add(0, a); :}
    | argument:a
    {: ArrayList<FunProcArgs> lst = new ArrayList<FunProcArgs>(); lst.add(a); RESULT = Optional.of(lst); :}
    ;

argument ::= ID:i COLON type:t
    {: RESULT = new FunProcArgs (i.value, t); :}
    ;

typeLst ::= type:t COMMA typeLst:l
    {: RESULT = l.add(0, t); :}
    | type:t
    {: ArrayList<Type> lst = new ArrayList<Type>(); lst.add(t); RESULT = Optional.of(lst); :}
    ;

type ::= INTTYPE
    {: RESULT = new IntType(); :}
    | BOOLTYPE
    {: RESULT = new BoolType(); :}
    | type:t LBRACK RBRACK
    {: RESULT = new ArrayType(t); :}
    | type:t LBRACK INT:i RBRACK
    {: RESULT = new ArrayType(t, i); :}
    ;

blockStmt ::= LBRACE stmtLst:s RBRACE
    {: RESULT = new BlockStmt(s); :}
    | // empty block
    {: ArrayList<Statement> lst = new ArrayList<Statement>(); Result = new BlockStmt(lst); :}
    ;

stmtLst ::= stmt:s stmtLst:l optSemi
    {: l.add(0, s); :}
    | stmt:s
    {: ArrayList<Statement> lst = new ArrayList<Statement>(); lst.add(s); RESULT = lst; :}
    ;

stmt ::= assign:s
    {: RESULT = s; :}
    | ifStmt:s
    {: RESULT = s; :}
    | whileStmt:s
    {: RESULT = s; :}
    | procCall:s
    {: RESULT = s; :}
    | LBRACE blockStmt:s RBRACE
    {: RESULT = s;:}
    | varDecl:s
    {: RESULT = s; :}
    ;

assign ::= lftValue:v ASSIGN expr:e
    {: RESULT = new AssignStmt(v, e); :}
    ;

lftValue ::= ID:i
    {: RESULT = new VarExpr(i.value); :}
    | varDecl:v
    {: RESULT = v; :}
    | UNDERSCORE
    {: RESULT = null;:}
    | arrIndexExpr:a
    {: RESULT = a; :}
    ;

arrIndexExpr ::= ID:i LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(i.value, e); :}
    | funCall:f LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(f, e); :}
    | arrIndexExpr:a LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(a, e); :}
    ;

funCall ::= ID:i LPAREN exprLst:e RPAREN
    {: RESULT = new FunCallExpr(i.value, e); :}
    | LENGTH LPAREN expr:e RPAREN
    {: ArrayList<Expr> lst = new ArrayList<Expr>(); lst.add(e); RESULT = new FunCallExpr("length", lst); :}
    ;

ifStmt ::= IF expr:e stmt:s
    {: RESULT = new ifStmt(e, s);:}
    | IF LPAREN expr:e RPAREN stmt:s
    {: RESULT = new ifStmt(e, s);:}
    | IF expr:e stmt:s1 ELSE stmt:s2
    {: RESULT = new ifStmt(e, s1, s2);:}
    | IF LPAREN expr:e RPAREN stmt:s1 ELSE stmt:s2
    {: RESULT = new ifStmt(e, s1, s2);:}
    ; /// ifStmt constructer

//OR if and while statements
whileStmt ::= WHILE expr:e stmt:s
    {: RESULT = new WhileStmt(e, s);:}
    |WHILE LPAREN expr:e RPAREN stmt:s
    {: RESULT = new WhileStmt(e, s);:}
    ;

procCall ::= ID:i LPAREN optArgLst:a RPAREN
    {: RESULT = new ProcCallStmt(i, a); :}
    ;

//variable declaration TODO: multiple declaraton
varDecl ::= ID:i COLON type:t
    {: RESULT = null;:};

returnStmt ::= RETURN expr_list:l optSemi
    {: RESULT = new ReturnStmt(l); :}
    ;

expr ::=
    |NOT expre:e
    {: RESULT = new Not(e);:} %prec UNARY
    | expre:e1 MULT expre:e2
    {: RESULT = new Mult(e1, e2);:}
    |expre:e1 HIGHMULT expre:e2
    {: RESULT = new HighMult(e1, e2);:}
    | expre:e1 DIV expre:e2
    {: RESULT = new Div(e1, e2);:}
    |expre:e1 MOD expre:e2
    {: RESULT = new Mod(e1, e2);:}
    |expre:e1 ADD expre:e2
    {: RESULT = new Add(e1, e2);:}
    | expre:e1 SUB expre:e2
    {: RESULT = new Sub(e1, e2);:}
    | sub expre:e
    {: RESULT = new IntNeg(e);:} %prec UNARY
    |expre:e1 LT expre:e2
    {: RESULT = new LessThan(e1, e2);:}
    | expre:e1 LEQ expre:e2
    {: RESULT = new LessEq(e1, e2);:}
    |expre:e1 GEQ expre:e2
    {: RESULT = new GreaterEq(e1, e2);:}
    | expre:e1 GT expre:e2
    {: RESULT = new GreaterThan(e1, e2);:}
    | expre:e1 EQ expre:e2
    {: RESULT = new Equal(e1, e2);:}
    |expre:e1 NEQ expre:e2
    {: RESULT = new NotEqual(e1, e2);:}
    | expre:e1 AND expre:e2
    {: RESULT = new And(e1, e2);:}
    | expre:e1 OR expre:e2
    {: RESULT = new Or(e1, e2);:}
    | indexable:i
    {: RESULT = i; :}
    ;

indexable ::= ID:i
    {: RESULT = new VarExpr(i.value); :}
    ;