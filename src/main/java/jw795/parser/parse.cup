//package jw795.parser;

import java_cup.runtime.*;
import jw795.ast.*;
import java.util.ArrayList;
import java.util.Optional;
import jw795.lexer.Lexer;
import jw795.lexer.LexerAdapter;

parser code
    {: public void syntax_error(java_cup.runtime.Symbol cur) {
        throw new RuntimeException(String.format( "%d:%d error: unexpected `%s`", cur.left, cur.right,
              lexer.LexerAdapter.tokenTypeToString(Lexer.TokenType.values()[cur.sym])));
        }
    :}
    ;

/* Terminals */
terminal    Symbol   USE, IF, WHILE, ELSE, RETURN, LENGTH, NOT, MULT, HIGHMULT, DIV, MOD, ADD, SUB, LT, LEQ, GEQ, GT,
                     EQ, NEQ, AND, OR, COLON, ASSIGN, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, SEMICOLON,
                     UNDERSCORE;

terminal    Symbol   INT, BOOL, INTTYPE, BOOLTYPE, ID, CHARLIT, STRINGLIT;
terminal    Symbol   PROGRAM_FILE, INTERFACE_FILE;
terminal    Symbol   UNARY;

/* Non terminals */
non terminal file;

non terminal Interface interface;
non terminal ArrayList<FunctionDeclare> funcDeclLst;
non terminal FunctionDecl funcDecl;

non terminal Program program;
//non terminal ArrayList<FunctionDefine> funcDefLst;
non terminal ArrayList<Definition> definitionLst;
non terminal ArrayList<Definition> optGlobalLst;
non terminal ArrayList<Definition> globalLst;
non terminal ArrayList<Definition> optDefinitionLst;
non terminal Definition global;
non terminal FunctionDefine funcDef;
non terminal ArrayList<Use> useLst;

non terminal function;
non terminal procedure;

non terminal ArrayList<FunProcArgs> optArgLst;
non terminal ArrayList<FunProcArgs> argLst;
non terminal funProcArgs argument;
non terminal Type argType;
non terminal Type arrNone;
non terminal Type arrSome;
non terminal Type arrAll;
non terminal ArrayList<Type> optTypeLst;
non terminal ArrayList<Type> typeLst;
non terminal Type primitiveType;
non terminal Type type;

non terminal BlockStmt blockStmt;
non terminal ArrayList<Statement> stmtLst;
non terminal Statement stmt;
non terminal AssignStmt assign;
non terminal AssignStmt multAssign;
non terminal ReturnStmt returnStmt;
non terminal IfStmt ifStmt;
non terminal WhileStmt whileStmt;
non terminal ProcCallStmt procCall;
non terminal VarDeclareStmt varDecl;
non terminal ArrayList<varDecl> varDeclLst;

non terminal LValue lftValue;
non terminal ArrrayList<LValue> optlftValueLst;
non terminal ArrIndexExpr arrIndexExpr;
non terminal FunCallExpr funCall;

non terminal Expr expr;
non terminal ArrayList<Expr> exprLst;
//non terminal ASTNode indexable;

non terminal optSemi;

/* Precedences */
precedence nonassoc IF;
precedence nonassoc ELSE;
precedence nonassoc ASSIGN;

precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LEQ, GEQ, GT;
precedence left ADD, SUB;
precedence left MULT, HIGHMULT, DIV, MOD;
precedence right UNARY;
precedence left LBRACK;

/* The grammar rules */
//This indicates which non-terminal is the start or goal non-terminal for parsing
start with file;

optSemi ::= SEMICOLON
    | // no semicolon
    ;

file ::= INTERFACE_FILE interface:i
        {: RESULT = i; :}
        | PROGRAM_FILE program:p
        {: RESULT = p; :}
        ;

//A program contains (use*) (global variable) (function*)
// int and bool can be declared and initialized + arr cannot be initialized but can be declared

//program ::= ((use∗) (definition∗))
program ::= useLst:u definitionLst:d
    {: RESULT = new Program(u, d); :}
    ;


//definition ::= method | globdecl
definitionLst ::= optGlobalLst:gl optDefinitionLst:dl
    {: gl.addAll(dl); RESULT = gl; :}
    ;


optGlobalLst ::= global:g optGlobalLst:l
    {: l.add(0, g); RESULT = l; :}
    | funcDef:f
    {: ArrayList<Definition> lst = new ArrayList<Definition>(); lst.add(f); RESULT = lst; :}
    ;


optDefinitionLst ::= global:g optDefinitionLst:lst
    {: lst.add(0, g); RESULT = lst; :}
    | funcDef:f optDefinitionLst:lst
    {: lst.add(0, f); RESULT = lst; :}
    | //no more definition in the program
    {: RESULT = new ArrayList<Definition>(); :}
    ;


global ::= ID:i COLON primitiveType:t optSemi
    {: RESULT = new GlobaDeclare(i.value, t); :}
    | ID:i COLON INTTYPE ASSIGN INT:n optSemi
    {: RESULT = new AssignStmt (new GlobaDeclare(i.value, new IntType()), new IntLiteral(n.value)); :}
    | ID:i COLON BOOLTYPE ASSIGN BOOL:b optSemi
    {: RESULT = new AssignStmt (new GlobaDeclare(i.value, new BoolType()), new BoolLiteral(b.value)); :}
    ;

useLst ::= useLst:ul USE ID:i optSemi
    {: ul.add(new Use(i)); RESULT = ul; :}
    | // empty or end of useLst
    {: RESULT = new ArrayList<Use>(); :}
    ;

//funcDefLst ::= funcDef:f funcDefLst:dl
//    {: dl.add(f); RESULT = dl; :}
//    | funcDef:f
//    {: ArrayList<FunctionDefine> lst = new ArrayList<>(FunctionDefine); lst.add(f); RESULT = lst;:}
//    ;

funcDef ::= function:f
    {: RESULT = f; :}
    | procedure:p
    {: RESULT = p; :}
    ;

function ::= ID:i LPAREN optArgLst:a RPAREN COLON optTypeLst:t blockStmt:b
    {: RESULT = new FunctionDefine(i.value, t, a, b); :}
    ;

procedure ::= ID LPAREN optArgLst:a RPAREN blockStmt:b
    {: RESULT = new FunctionDefine(i.value, Optional.empty(), a, b); :}
    ;

//An interface contains a nonempty set of procedure and function declaration without implementation
interface ::= funcDeclLst:f
    {: RESULT = new Interface(f); :}
    ;

funcDeclLst ::= funcDecl:f funcDeclLst:d
    {: RESULT = d.add(0, f); :}
    | funcDecl:f
    {: ArrayList<FunctionDeclare> lst = new ArrayList<FunctionDeclare>(); lst.add(f); Result = lst; :}
    ;

funcDecl ::= ID:i LPAREN optArgLst:a RPAREN COLON typeLst:t
    {: RESULT = new FunctionDeclare(i.value, a, t); :}
    | ID:i LPAREN optArgLst:a RPAREN
    {: RESULT = new FunctionDeclare(i.value, a, Optional.empty()); :}
    ;

optArgLst ::= argLst:a
    {: RESULT = a; :}
    | // no argument
    {: RESULT = Optional.empty(); :}
    ;

argLst ::= argument:a COMMA argLst:l
    {: RESULT = l.add(0, a); :}
    | argument:a
    {: ArrayList<FunProcArgs> lst = new ArrayList<FunProcArgs>(); lst.add(a); RESULT = Optional.of(lst); :}
    ;

argument ::= ID:i COLON argType:t
    {: RESULT = new FunProcArgs (i.value, t); :}
    ;

argType ::= INTTYPE
    {: RESULT = new IntType(); :}
    | BOOLTYPE
    {: RESULT = new BoolType(); :}
    | type:t LBRACK RBRACK
    {: RESULT = new ArrayType(t); :}
    ;

primitiveType ::= INTTYPE:i
    {: RESULT = new IntType(); :}
    | BOOLTYPE:b
    {: RESULT = new BoolType(); :}
    ;

type ::= arrNone:a
    {: RESULT = new ArrayType(a, Optional.empty()); :}
    | arrSome:a
    {: RESULT = new ArrayType(a, Optional.empty()); :}
    | arrAll:a
    {: RESULT = a; :}
    ;

arrNone ::= arrNone:a LBRACK RBRACK
    {: RESULT = new ArrayType(a, Optional.empty()); :}
    | primitiveType:p LBRACK RBRACK
    {: RESULT = p; :}
    ;

arrSome ::= arrSome:a LBRACK RBRACK
    {: RESULT = new ArrayType(a, Optional.empty()); :}
    | arrAll:a LBRACK RBRACK
    {: RESULT = a; :}
    ;

arrAll ::= arrAll:a LBRACK expr:e RBRACK
    {: RESULT = new ArrayType(a, Optional.of(e)); :}
    | primitiveType:p
    {: RESULT = p; :}
    ;

typeLst ::= type:t COMMA typeLst:l
    {: RESULT = l.add(0, t); :}
    | type:t
    {: ArrayList<Type> lst = new ArrayList<Type>(); lst.add(t); RESULT = Optional.of(lst); :}
    ;

blockStmt ::= LBRACE stmtLst:s RBRACE
    {: RESULT = new BlockStmt(s); :}
    | LBRACE stmtLst:s returnStmt:r RBRACE
    {: s.add(r); RESULT = new BlockStmt(s); :}
    ;

stmtLst ::= stmt:s optSemi stmtLst:l
    {: l.add(0, s); :}
    | // empty block or end of block
    {: RESULT = new ArrayList<Statement>(); :}
    ;

stmt ::= assign:s
    {: RESULT = s; :}
    |multAssign:s
    {: RESULT = s; :}
    | ifStmt:s
    {: RESULT = s; :}
    | whileStmt:s
    {: RESULT = s; :}
    | procCall:s
    {: RESULT = s; :}
    | blockStmt:s
    {: RESULT = s;:}
    | varDecl:s
    {: RESULT = s; :}
    ;

assign ::= lftValue:v ASSIGN expr:e
    {: RESULT = new AssignStmt(v, e); :}
    ;

lftValue ::= ID:i
    {: RESULT = new VarExpr(i.value); :}
    | varDecl:v
    {: RESULT = v; :}
    | arrIndexExpr:a
    {: RESULT = a; :}
    ;

varDecl ::= ID:i COLON type:t
    {: RESULT = new VarDeclareStmt(i, t);:}
    | UNDERSCORE
    {: RESULT = new WildCard(); :}
    ;

arrIndexExpr ::= ID:i LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(i.value, e); :}
    | funCall:f LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(f, e); :}
    | arrIndexExpr:a LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(a, e); :}
    ;

multAssign ::= varDeclLst:l ASSIGN funCall:f
    {: RESULT = new AssignStmt(new LeftValueList(l), f); :}
    ;

//variable declaration
varDeclLst ::= varDecl:v COMMA varDeclLst:l
    {: l.add(0, v); RESULT = l; :}
    | varDecl:v1 COMMA varDecl:v2
    {: ArrayList<LValue> lst = new ArrayList<LValue>(); lst.add(v1); lst.add(v2); RESULT = lst; :}
    ;

funCall ::= ID:i LPAREN exprLst:e RPAREN
    {: RESULT = new FunCallExpr(i.value, e); :}
    | ID:i LPAREN RPAREN
    {: RESULT = new FunCallExpr(i.value, new ArrayList<Expr>()); :}
    | LENGTH LPAREN expr:e RPAREN
    {: ArrayList<Expr> lst = new ArrayList<Expr>(); lst.add(e); RESULT = new FunCallExpr("length", lst); :}
    ;

// function can take in 0 or more arguments (/expression)
exprLst ::= expr:e COMMA exprLst:l
    {: RESULT = l.add(0, e); :}
    | expr:e
    {: ArrayList<Type> lst = new ArrayList<Type>(); lst.add(e); RESULT = lst; :}
    ;

ifStmt ::= IF expr:e stmt:s
    {: RESULT = new ifStmt(e, s);:}
    | IF expr:e stmt:s1 ELSE stmt:s2
    {: RESULT = new ifStmt(e, s1, s2); :}
    ; /// ifStmt constructer

//OR if and while statements
whileStmt ::= WHILE expr:e stmt:s
    {: RESULT = new WhileStmt(e, s); :}
    ;

procCall ::= ID:i LPAREN exprLst:a RPAREN
    {: RESULT = new ProcCallStmt(i, a); :}
    | ID:i LPAREN RPAREN
    {: RESULT = new ProcCallStmt(i, new ArrayList<Expr>()); :}
    ;

returnStmt ::= RETURN exprLst:l optSemi
    {: RESULT = new ReturnStmt(l); :}
    ;

expr ::= INT: i
    {: RESULT = new IntLiteral(i.value, i.left, i.right); :}
    | BOOL: b
    {: RESULT = new BoolLiteral(b.value, b.left, b.right); :}
    | CHARLIT: c
    {: RESULT = new CharLiteral(c.value, c.left, c.right); :}
    | STRINGLIT: s
    {: RESULT = new StringLit(s.value, s.left, s.right); :}
    | STRINGLIT:s LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(new StringLit (s.value, s.left, s.right), e, s.left, s.right); :}
    | LPAREN expr:e RPAREN
    {: RESULT = e; :}
    | NOT:not expr:e
    {: RESULT = new Not(e, not.left, not.right);:} %prec UNARY
    | expr:e1 MULT expr:e2
    {: RESULT = new Mult(e1, e2, e1.left, e1.right);:}
    | expr:e1 HIGHMULT expr:e2
    {: RESULT = new HighMult(e1, e2, e1.left, e1.right);:}
    | expr:e1 DIV expr:e2
    {: RESULT = new Div(e1, e2, e1.left, e1.right);:}
    | expr:e1 MOD expr:e2
    {: RESULT = new Mod(e1, e2, e1.left, e1.right);:}
    | expr:e1 ADD expr:e2
    {: RESULT = new Add(e1, e2, e1.left, e1.right);:}
    | expr:e1 SUB expr:e2
    {: RESULT = new Sub(e1, e2, e1.left, e1.right);:}
    | SUB:sub expr:e
    {: RESULT = new IntNeg(e, sub.left, sub.right);:} %prec UNARY
    | expr:e1 LT expr:e2
    {: RESULT = new LessThan(e1, e2, e1.left, e1.right);:}
    | expr:e1 LEQ expr:e2
    {: RESULT = new LessEq(e1, e2, e1.left, e1.right);:}
    | expr:e1 GEQ expr:e2
    {: RESULT = new GreaterEq(e1, e2, e1.left, e1.right);:}
    | expr:e1 GT expr:e2
    {: RESULT = new GreaterThan(e1, e2, e1.left, e1.right);:}
    | expr:e1 EQ expr:e2
    {: RESULT = new Equal(e1, e2, e1.left, e1.right);:}
    | expr:e1 NEQ expr:e2
    {: RESULT = new NotEqual(e1, e2, e1.left, e1.right);:}
    | expr:e1 AND expr:e2
    {: RESULT = new And(e1, e2, e1.left, e1.right);:}
    | expr:e1 OR:o expr:e2
    {: RESULT = new Or(e1, e2, e1.left, e1.right);:}
    ;