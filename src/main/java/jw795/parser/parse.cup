package jw795.parser;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Optional;
import jw795.ast.*;
import jw795.lexer.Lexer;
import jw795.lexer.LexerAdapter;

/**
 * syntax_error(java_cup.runtime.Symbol cur) overrides the default function in the generated parser class
 * to throw an RuntimeException with an error message reporting the Symbol location and type.
 */
parser code
    {:
        public void syntax_error(java_cup.runtime.Symbol cur) {
            throw new RuntimeException(String.format( "%d:%d error: unexpected `%s`", cur.left, cur.right,
                  lexer.LexerAdapter.tokenTypeToString(Lexer.TokenType.values()[cur.sym])));
        }
    :}
    ;

/* Terminals */
terminal    Symbol   USE, IF, WHILE, ELSE, RETURN, LENGTH, NOT, MULT, HIGHMULT, DIV, MOD, ADD, SUB, LT, LEQ, GEQ, GT,
                     EQ, NEQ, AND, OR, COLON, ASSIGN, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, SEMICOLON,
                     UNDERSCORE;

terminal    Symbol   INT, BOOL, INTTYPE, BOOLTYPE, ID, CHARLIT, STRINGLIT;
terminal    Symbol   PROGRAM_FILE, INTERFACE_FILE;
terminal    Symbol   UNARY;

/* Non terminals */
non terminal file;

// interface
non terminal Interface interface;
non terminal ArrayList<ProcFuncDecl> procFuncDeclLst;
non terminal ProcFuncDecl procFuncDecl;

// program
non terminal Program program;
non terminal ArrayList<Definition> definitionLst;
non terminal ArrayList<Definition> optGlobalLst;
non terminal ArrayList<Definition> optDefinitionLst;
non terminal Definition global;
non terminal Definition procFuncDef;
non terminal ProcedureDefine procDef;
non terminal FunctionDefine funcDef;
non terminal ArrayList<Use> useLst;
non terminal ArrayList<FunProcArgs> optArgLst;
non terminal ArrayList<FunProcArgs> argLst;
non terminal FunProcArgs argument;
non terminal Type argRetType;

// type
non terminal Type type;
non terminal Type primitiveType;
non terminal Type arrNone;
non terminal Type arrSome;
non terminal Type arrAll;
non terminal ArrayList<Type> argRetTypeLst;

// statement
non terminal BlockStmt blockStmt;
non terminal ArrayList<Statement> stmtLst;
non terminal Statement stmt;
non terminal AssignStmt assign;
non terminal AssignStmt multAssign;
non terminal ReturnStmt returnStmt;
non terminal Statement ifStmt;
non terminal WhileStmt whileStmt;
non terminal ProcCallStmt procCall;
non terminal VarDeclareStmt varDecl;
non terminal ArrayList<VarDeclareStmt> varDeclLst;

// expressions
non terminal Expr expr;
non terminal ArrayList<Expr> exprLst;
non terminal LValue lftValue;
non terminal ArrIndexExpr arrIndexExpr;
non terminal FunCallExpr funCall;

// punctuation
non terminal optSemi;

/* Precedences */
precedence nonassoc IF;
precedence nonassoc ELSE;
precedence nonassoc ASSIGN;

precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LEQ, GEQ, GT;
precedence left ADD, SUB;
precedence left MULT, HIGHMULT, DIV, MOD;
precedence right UNARY;
precedence left LBRACK;

/* The grammar rules */

/**
* ===== FILE PROCESSING ====
* A file can be either a program file or an interface file. A Symbol is used to indicate which file it is.
*/
start with file;

file ::= INTERFACE_FILE interface:i
        {: RESULT = i; :}
        | PROGRAM_FILE program:p
        {: RESULT = p; :}
        ;

/**
* ===== INTERFACE PROCESSING ====
* The general syntax of an interface is defined as interface ::= ((procFuncDec∗))
*/
interface ::= procFuncDeclLst:f
    {: int line = f.get(0).line;
       int col = f.get(0).col;
       RESULT = new Interface(f, line, col); :}
    ;

procFuncDeclLst ::= procFuncDecl:f optSemi procFuncDeclLst:d
    {: d.add(0, f); RESULT = d; :}
    | procFuncDecl:f
    {: ArrayList<ProcFuncDecl> lst = new ArrayList<ProcFuncDecl>(); lst.add(f); RESULT = lst; :}
    ;

procFuncDecl ::= ID:i LPAREN optArgLst:a RPAREN
    {: RESULT = new ProcedureDeclare(String.valueOf(i.value), a, i.left, i.right); :}
    | ID:i LPAREN optArgLst:a RPAREN COLON argRetTypeLst:t
    {: RESULT = new FunctionDeclare(String.valueOf(i.value), a, t, i.left, i.right); :}
    ;

optArgLst ::= argLst:a
    {: RESULT = a; :}
    | // no argument was passed in
    {: RESULT = new ArrayList<FunProcArgs>(); :}
    ;

argLst ::= argument:a COMMA argLst:l
    {: l.add(0, a); RESULT = l; :}
    | argument:a
    {: ArrayList<FunProcArgs> lst = new ArrayList<FunProcArgs>(); lst.add(a); RESULT = lst; :}
    ;

argument ::= ID:i COLON argRetType:t
    {: RESULT = new FunProcArgs (String.valueOf(i.value), t, i.left, i.right); :}
    ;

argRetType ::= INTTYPE:t
    {: RESULT = new IntType(t.left, t.right); :}
    | BOOLTYPE: t
    {: RESULT = new BoolType(t.left, t.right); :}
    | argRetType:t LBRACK RBRACK
    {: RESULT = new ArrayType(t, t.line, t.col); :}
    ;

argRetTypeLst ::= argRetType:a COMMA argRetTypeLst:l
    {: l.add(0, a); RESULT = l; :}
    | argRetType:a
    {: ArrayList<Type> lst = new ArrayList<Type>(); lst.add(a); RESULT = lst; :}
    ;

optSemi ::= SEMICOLON
    | // no semicolon
    ;

/**
* ===== PROGRAM PROCESSING ====
* The general syntax of an interface is defined as program ::= ((use∗) (definition∗))
*/
program ::= useLst:u definitionLst:d
    {:
        int l;
        int c;
        if (u.isEmpty()) {
            l = d.get(0).line;
            c = d.get(0).col;
        } else {
            l = u.get(0).line;
            c = u.get(0).col;
        }
        RESULT = new Program(u, d, l, c);
    :}
    ;

// use ::= (use <id>)
useLst ::= useLst:ul USE:u ID:i optSemi
    {: ul.add(new Use(String.valueOf(i.value), u.left, u.right)); RESULT = ul; :}
    | // empty or end of useLst
    {: RESULT = new ArrayList<Use>(); :}
    ;

// definition ::= method | globdecl
definitionLst ::= optGlobalLst:gl optDefinitionLst:dl
    {: gl.addAll(dl); RESULT = gl; :}
    ;

optGlobalLst ::= global:g optGlobalLst:l
    {: l.add(0, g); RESULT = l; :}
    | procFuncDef:f
    {: ArrayList<Definition> lst = new ArrayList<Definition>(); lst.add(f); RESULT = lst; :}
    ;

// globdec ::= (<id> type) |  (<id> type <value>)
global ::= ID:i COLON argRetType:t optSemi
    {: RESULT = new GlobDeclare(String.valueOf(i.value), t, i.left, i.right); :}
    | ID:i COLON INTTYPE:t ASSIGN INT:n optSemi
    {:
        RESULT = new AssignStmt (
            new GlobDeclare(String.valueOf(i.value), new IntType(t.left, t.right), i.left, i.right),
            new IntLiteral(String.valueOf(n.value), n.left, n.right),
            i.left,
            i.right
        );
    :}
    | ID:i COLON BOOLTYPE:t ASSIGN BOOL:b optSemi
    {:
        RESULT = new AssignStmt (
            new GlobDeclare(String.valueOf(i.value), new BoolType(t.left, t.right), i.left, i.right),
            new BoolLiteral(Boolean.valueOf(b.value), b.left, b.right),
            i.left,
            i.right
        );
    :}
    ;

optDefinitionLst ::= global:g optDefinitionLst:lst
    {: lst.add(0, g); RESULT = lst; :}
    | procFuncDef:f optDefinitionLst:lst
    {: lst.add(0, f); RESULT = lst; :}
    | //no more definition in the program
    {: RESULT = new ArrayList<Definition>(); :}
    ;

procFuncDef ::= procDef:d
    {: RESULT = d; :}
    | funcDef:d
    {: RESULT = d; :}
    ;

procDef ::= ID:i LPAREN optArgLst:a RPAREN blockStmt:b
    {: RESULT = new ProcedureDefine(String.valueOf(i.value), a, b, i.left, i.right); :}
    ;

funcDef ::= ID:i LPAREN optArgLst:a RPAREN COLON argRetTypeLst:t blockStmt:b
    {: RESULT = new FunctionDefine(String.valueOf(i.value), t, a, b, i.left, i.right); :}
    ;

/**
* ===== BLOCK PROCESSING ====
* The general syntax of an interface is defined as Block ::= (stmt*)
*/
blockStmt ::= LBRACE:l stmtLst:s RBRACE
    {: RESULT = new BlockStmt(s, l.left, l.right); :}
    | LBRACE:l stmtLst:s returnStmt:r RBRACE
    {: s.add(r); RESULT = new BlockStmt(s, l.left, l.right); :}
    ;

returnStmt ::= RETURN:r exprLst:l optSemi
    {: RESULT = new ReturnStmt(l, r.left, r.right); :}
    ;

/**
* ===== STATEMENT PROCESSING ====
* The general syntax of an interface is defined as
* stmt ::=  ifStmt | whileStmt | procCall | assign | multiAssign | blockStmt | varDecl
*/
stmtLst ::= stmt:s optSemi stmtLst:l
    {: l.add(0, s); :}
    | // empty block or end of block
    {: RESULT = new ArrayList<Statement>(); :}
    ;

stmt ::= ifStmt:s
    {: RESULT = s; :}
    | whileStmt:s
    {: RESULT = s; :}
    | procCall:s
    {: RESULT = s; :}
    | assign:s
    {: RESULT = s; :}
    | multAssign:s
    {: RESULT = s; :}
    | blockStmt:s
    {: RESULT = s;:}
    | varDecl:s
    {: RESULT = s; :}
    ;

ifStmt ::= IF:i expr:e stmt:s
    {: RESULT = new IfStmt(e, s, i.left, i.right);:}
    | IF:i expr:e stmt:s1 ELSE stmt:s2
    {: RESULT = new IfElseStmt(e, s1, s2, i.left, i.right); :}
    ;

whileStmt ::= WHILE:w expr:e stmt:s
    {: RESULT = new WhileStmt(e, s, w.left, w.right); :}
    ;

procCall ::= ID:i LPAREN exprLst:a RPAREN
    {: RESULT = new ProcCallStmt(String.valueOf(i.value), a, i.left, i.right); :}
    | ID:i LPAREN RPAREN
    {: RESULT = new ProcCallStmt(String.valueOf(i.value), new ArrayList<Expr>(), i.left, i.right); :}
    ;

// Single Assignment is defined as Assign ::= (ID | varDecl | arrIndexExpr) ASSIGN expr
assign ::= lftValue:v ASSIGN expr:e
    {: RESULT = new AssignStmt(v, e, v.left, v.right); :}
    ;

lftValue ::= ID:i
    {: RESULT = new VarExpr(String.valueOf(i.value), i.left, i.right); :}
    | varDecl:v
    {: RESULT = v; :}
    | arrIndexExpr:a
    {: RESULT = a; :}
    ;

type ::= arrNone:a
    {: RESULT = new ArrayType(a, a.line, a.col); :}
    | arrSome:a
    {: RESULT = new ArrayType(a, a.line, a.col); :}
    | arrAll:a
    {: RESULT = a; :}
    ;

arrNone ::= arrNone:a LBRACK RBRACK
    {: RESULT = new ArrayType(a, a.line, a.col); :}
    | primitiveType:p LBRACK RBRACK
    {: RESULT = p; :}
    ;

primitiveType ::= INTTYPE:i
    {: RESULT = new IntType(i.left, i.right); :}
    | BOOLTYPE:b
    {: RESULT = new BoolType(b.left, b.right); :}
    ;

arrSome ::= arrSome:a LBRACK RBRACK
    {: RESULT = new ArrayType(a, a.line, a.col); :}
    | arrAll:a LBRACK RBRACK
    {: RESULT = a; :}
    ;

arrAll ::= arrAll:a LBRACK expr:e RBRACK
    {: RESULT = new ArrayType(a, e, a.line, a.col); :}
    | primitiveType:p
    {: RESULT = p; :}
    ;

expr ::= INT: i
    {: RESULT = new IntLiteral((int)i.value, i.left, i.right); :}
    | BOOL: b
    {: RESULT = new BoolLiteral(b.value.booleanValue(), b.left, b.right); :}
    | CHARLIT: c
    {: RESULT = new CharLiteral((char)c.value, c.left, c.right); :}
    | STRINGLIT: s
    {: RESULT = new StringLit(String.valueOf(s.value), s.left, s.right); :}
    | STRINGLIT:s LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(new StringLit (String.valueOf(s.value), s.left, s.right), e, s.left, s.right); :}
    | LPAREN expr:e RPAREN
    {: RESULT = e; :}
    | NOT:not expr:e
    {: RESULT = new Not(e, not.left, not.right);:} %prec UNARY
    | expr:e1 MULT expr:e2
    {: RESULT = new Mult(e1, e2, e1.left(), e1.right());:}
    | expr:e1 HIGHMULT expr:e2
    {: RESULT = new HighMult(e1, e2, e1.left(), e1.right());:}
    | expr:e1 DIV expr:e2
    {: RESULT = new Div(e1, e2, e1.left(), e1.right());:}
    | expr:e1 MOD expr:e2
    {: RESULT = new Mod(e1, e2, e1.left(), e1.right());:}
    | expr:e1 ADD expr:e2
    {: RESULT = new Add(e1, e2, e1.left(), e1.right());:}
    | expr:e1 SUB expr:e2
    {: RESULT = new Sub(e1, e2, e1.left(), e1.right());:}
    | SUB:sub expr:e
    {: RESULT = new IntNeg(e, sub.left, sub.right);:} %prec UNARY
    | expr:e1 LT expr:e2
    {: RESULT = new LessThan(e1, e2, e1.left(), e1.right());:}
    | expr:e1 LEQ expr:e2
    {: RESULT = new LessEq(e1, e2, e1.left(), e1.right());:}
    | expr:e1 GEQ expr:e2
    {: RESULT = new GreaterEq(e1, e2, e1.left(), e1.right());:}
    | expr:e1 GT expr:e2
    {: RESULT = new GreaterThan(e1, e2, e1.left(), e1.right());:}
    | expr:e1 EQ expr:e2
    {: RESULT = new Equal(e1, e2, e1.left(), e1.right());:}
    | expr:e1 NEQ expr:e2
    {: RESULT = new NotEqual(e1, e2, e1.left(), e1.right());:}
    | expr:e1 AND expr:e2
    {: RESULT = new And(e1, e2, e1.left(), e1.right());:}
    | expr:e1 OR expr:e2
    {: RESULT = new Or(e1, e2, e1.left(), e1.right());:}
    ;

arrIndexExpr ::= ID:i LBRACK expr:e RBRACK
    {:
        VarExpr expr = new VarExpr(String.valueOf(i.value), i.left, i.right);
        RESULT = new ArrIndexExpr(expr, e, i.left, i.right);
    :}
    | funCall:f LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(f, e, f.left(), f.right()); :}
    | arrIndexExpr:a LBRACK expr:e RBRACK
    {: RESULT = new ArrIndexExpr(a, e, a.line, a.col); :}
    ;

funCall ::= ID:i LPAREN exprLst:e RPAREN
    {: RESULT = new FunCallExpr(String.valueOf(i.value), e, i.left, i.right); :}
    | ID:i LPAREN RPAREN
    {: RESULT = new FunCallExpr(String.valueOf(i.value), new ArrayList<Expr>(), i.left, i.right); :}
    | LENGTH:len LPAREN expr:e RPAREN
    {: ArrayList<Expr> lst = new ArrayList<Expr>();
       lst.add(e);
       RESULT = new FunCallExpr("length", lst, len.left, len.right); :}
    ;

exprLst ::= expr:e COMMA exprLst:l
    {: l.add(0, e); RESULT = l; :}
    | expr:e
    {: ArrayList<Expr> lst = new ArrayList<Expr>(); lst.add(e); RESULT = lst; :}
    ;

// multAssign ::= (varDecl*) ASSIGN funcCall
// Note that only varDecl can be on the left of ASSIGN in multiple assignment.
multAssign ::= varDeclLst:l ASSIGN funCall:f
    {: int line = l.get(0).line;
       int col = l.get(0).col;
       LeftValueList lst = new LeftValueList(l, line, col);
       RESULT = new AssignStmt(lst, f, line, col);
    :}
    ;

varDeclLst ::= varDecl:v COMMA varDeclLst:l
    {: l.add(0, v); RESULT = l; :}
    | varDecl:v1 COMMA varDecl:v2
    {: ArrayList<VarDeclareStmt> lst = new ArrayList<VarDeclareStmt>(); lst.add(v1); lst.add(v2); RESULT = lst; :}
    ;

varDecl ::= ID:i COLON type:t
    {: RESULT = new VarDeclareStmt(String.valueOf(i.value), t, i.left, i.right);:}
    | UNDERSCORE:u
    {: RESULT = new WildCard(u.left, u.right); :}
    ;
